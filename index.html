<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ocean-wave-visualizer</title>
  <meta name="description" content="Real-time ocean wave animation with day/night background using p5.js" />
  <!-- p5.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #000; }
    canvas { display: block; }
    .hud {
      position: fixed; left: 12px; bottom: 12px; z-index: 10;
      background: rgba(255,255,255,0.12); color: #fff;
      backdrop-filter: blur(6px);
      border-radius: 14px; padding: 10px 12px; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      box-shadow: 0 8px 20px rgba(0,0,0,0.25);
      line-height: 1.4; font-size: 12px;
    }
    .hud b { font-weight: 700; }
    .hud .row { display: flex; gap: 8px; align-items: center; }
    .hud button {
      cursor: pointer; border: 0; border-radius: 10px; padding: 6px 10px;
      background: rgba(255,255,255,0.2); color: #fff; font-weight: 600;
    }
    .hud input[type="range"]{ width: 160px; }
  </style>
</head>
<body>
  <!--
    ocean-wave-visualizer
    -------------------------------------------------------
    Features:
      • Multi-layer Gerstner-like waves (parallax + depth shading)
      • Day/Night sky that follows local time; smooth transitions
      • Stars at night; sun/moon glow; dynamic horizon haze
      • Simple HUD: toggle auto time, scrub time, pause

    Controls:
      [Space]  : Pause/Resume animation
      [T]      : Toggle auto-time (system clock) vs manual scrub
      [←/→]    : Adjust manual time when auto-time is off
      [S]      : Toggle stars

    Made with p5.js
  -->

  <div class="hud" id="hud">
    <div class="row" style="margin-bottom: 6px">
      <b>ocean-wave-visualizer</b>
    </div>
    <div class="row" style="margin-bottom: 6px">
      <span id="modeLabel">Auto time</span>
      <button id="toggleTime">Toggle [T]</button>
      <button id="pauseBtn">Pause [Space]</button>
      <button id="starsBtn">Stars [S]</button>
    </div>
    <div class="row">
      <input id="timeSlider" type="range" min="0" max="24" step="0.01" value="0" />
      <span id="timeLabel">00:00</span>
    </div>
  </div>

  <script>
    // --- Config ------------------------------------------------------------
    const LAYERS = [
      { amp: 16,  len: 420, speed: 0.35, color: [18, 82, 132], alpha: 220 }, // far
      { amp: 22,  len: 320, speed: 0.45, color: [12, 66, 112], alpha: 235 }, // mid
      { amp: 32,  len: 260, speed: 0.60, color: [8, 52, 96],   alpha: 245 }, // near
      { amp: 46,  len: 200, speed: 0.85, color: [4, 38, 78],   alpha: 255 }, // foreground
    ];

    let t = 0;                   // animation time
    let paused = false;          
    let autoTime = true;         // use system time for sky
    let manualHour = 8;          // fallback/manual time (0-24)
    let starsEnabled = true;
    let stars = [];

    function setup() {
      createCanvas(windowWidth, windowHeight);
      noStroke();
      initStars();
      setupHUD();
    }

    function windowResized(){
      resizeCanvas(windowWidth, windowHeight);
      initStars(true);
    }

    function initStars(preserveCount=false){
      const desired = Math.floor((width * height) / 12000); // density-based
      if (!preserveCount) stars = [];
      while (stars.length < desired) {
        stars.push({
          x: random(width), y: random(height * 0.65), // only above horizon
          s: random(0.5, 1.8), tw: random(0.5, 2),
          p: random(TAU)
        });
      }
      if (stars.length > desired) stars.length = desired;
    }

    // --- UI ------------------------------------------------------------
    function setupHUD(){
      const slider = document.getElementById('timeSlider');
      const label  = document.getElementById('timeLabel');
      const mode   = document.getElementById('modeLabel');
      const toggle = document.getElementById('toggleTime');
      const pauseB = document.getElementById('pauseBtn');
      const starsB = document.getElementById('starsBtn');

      // Initialize with local time
      const now = new Date();
      manualHour = now.getHours() + now.getMinutes()/60;
      slider.value = manualHour.toFixed(2);
      label.textContent = fmtHour(manualHour);

      slider.addEventListener('input', e => {
        manualHour = parseFloat(e.target.value);
        label.textContent = fmtHour(manualHour);
        if (autoTime) { autoTime = false; mode.textContent = 'Manual time'; }
      });

      toggle.addEventListener('click', () => {
        autoTime = !autoTime;
        mode.textContent = autoTime ? 'Auto time' : 'Manual time';
      });

      pauseB.addEventListener('click', () => { paused = !paused; pauseB.textContent = paused ? 'Resume [Space]' : 'Pause [Space]'; });
      starsB.addEventListener('click', () => { starsEnabled = !starsEnabled; });

      // Keyboard
      window.addEventListener('keydown', (e) => {
        if (e.key === ' ') { e.preventDefault(); paused = !paused; pauseB.textContent = paused ? 'Resume [Space]' : 'Pause [Space]'; }
        if (e.key.toLowerCase() === 't') { autoTime = !autoTime; mode.textContent = autoTime ? 'Auto time' : 'Manual time'; }
        if (e.key.toLowerCase() === 's') { starsEnabled = !starsEnabled; }
        if (!autoTime && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')){
          const delta = (e.key === 'ArrowLeft') ? -0.1 : 0.1; // 6 minutes steps
          manualHour = constrain(manualHour + delta, 0, 24);
          slider.value = manualHour;
          label.textContent = fmtHour(manualHour);
        }
      });
    }

    function fmtHour(h){
      const hh = floor(h) % 24;
      const mm = floor((h - floor(h)) * 60);
      return nf(hh,2) + ':' + nf(mm,2);
    }

    // --- Sky & Horizon -------------------------------------------------
    function currentHour(){
      if (autoTime){
        const now = new Date();
        return now.getHours() + now.getMinutes()/60 + now.getSeconds()/3600;
      }
      return manualHour;
    }

    function skyColors(h){
      // Define keyframes across the day
      // Returns [topColor, bottomColor, sunColor, moonColor, starAlpha]
      // Dawn  5-7, Day 7-17, Dusk 17-19, Night 19-5
      const c = (r,g,b) => color(r,g,b);

      const keyframes = [
        { h: 5,  top: c(12, 18, 48), bottom: c(255, 153, 102), starA: 150 }, // dawn start
        { h: 7,  top: c(86, 142, 212), bottom: c(170, 208, 255), starA: 0   }, // day start
        { h: 12, top: c(60, 130, 210), bottom: c(185, 225, 255), starA: 0   }, // noon
        { h: 17, top: c(70, 120, 200), bottom: c(255, 190, 150), starA: 0   }, // golden
        { h: 19, top: c(18, 24, 56),  bottom: c(10, 20, 60),    starA: 160 }, // night start
        { h: 24, top: c(10, 16, 40),  bottom: c(6, 10, 30),     starA: 180 }, // late night
      ];

      // Wrap 0-24 by duplicating first at 24
      keyframes.push({ ...keyframes[0], h: 29 }); // extend beyond 24 for interpolation near midnight
      let hAdj = h;
      if (hAdj < keyframes[0].h) hAdj += 24; // allow interpolation between 24->5

      // Find segment
      let i = 0; while (i < keyframes.length-1 && !(hAdj >= keyframes[i].h && hAdj <= keyframes[i+1].h)) i++;
      const k1 = keyframes[i], k2 = keyframes[i+1];
      const f = map(hAdj, k1.h, k2.h, 0, 1, true);

      const top    = lerpColor(k1.top, k2.top, f);
      const bottom = lerpColor(k1.bottom, k2.bottom, f);
      const starA  = lerp(k1.starA, k2.starA, f);

      // Sun/Moon positions along an arc
      const sunTheta  = map(hAdj % 24, 6, 18, -PI, 0);    // visible daytime
      const moonTheta = map((hAdj + 12) % 24, 6, 18, -PI, 0); // opposite arc
      return { top, bottom, sunTheta, moonTheta, starA };
    }

    function drawSky(){
      const h = currentHour();
      const { top, bottom, sunTheta, moonTheta, starA } = skyColors(h);

      // Vertical gradient sky
      for (let y = 0; y < height; y++){
        const f = y / height;
        const c = lerpColor(top, bottom, f);
        stroke(c);
        line(0, y, width, y);
      }

      // Haze near horizon
      const horizonY = height * 0.62;
      noStroke();
      for (let i=0; i<120; i++){
        const a = map(i, 0, 119, 0, 60);
        fill(255, 255, 255, a * 0.35);
        rect(0, horizonY + i, width, 1);
      }

      // Sun
      const sunR = min(width, height) * 0.08;
      const sunX = width * 0.5 + cos(sunTheta) * width * 0.35;
      const sunY = horizonY + sin(sunTheta) * height * 0.6;
      if (sunY < horizonY + sunR) {
        for (let r = sunR; r > 0; r -= 1){
          const a = map(r, 0, sunR, 180, 0);
          fill(255, 230, 160, a);
          circle(sunX, sunY, r*2);
        }
      }

      // Moon + glow
      const moonR = min(width, height) * 0.05;
      const moonX = width * 0.5 + cos(moonTheta) * width * 0.35;
      const moonY = horizonY + sin(moonTheta) * height * 0.6;
      if (moonY < horizonY + moonR) {
        for (let r = moonR*1.6; r > 0; r -= 1){
          const a = map(r, 0, moonR*1.6, 140, 0);
          fill(200, 220, 255, a);
          circle(moonX, moonY, r*2);
        }
        fill(235);
        circle(moonX, moonY, moonR*2);
        // simple crescent effect
        fill(10,15,28);
        circle(moonX + moonR*0.35, moonY, moonR*2);
      }

      // Stars
      if (starsEnabled){
        for (const s of stars){
          const twinkle = (sin((t*0.8 + s.p) * s.tw) + 1) * 0.5; // 0..1
          const a = twinkle * starA;
          if (a > 2){
            fill(255, 255, 255, a);
            circle(s.x, s.y, s.s);
          }
        }
      }

      return horizonY;
    }

    // --- Waves -----------------------------------------------------------
    function waveY(x, time, layer){
      // Gerstner-like (sum of sines) for richer surface
      const k = TAU / layer.len;
      const a1 = layer.amp, a2 = layer.amp * 0.55, a3 = layer.amp * 0.28;
      const s  = layer.speed;
      return (
        a1 * sin(k * x + time * s) +
        a2 * sin(k * x * 0.6 + time * s * 1.7 + 0.8) +
        a3 * sin(k * x * 1.7 + time * s * 0.45 + 1.6)
      );
    }

    function drawLayer(horizonY, idx){
      const layer = LAYERS[idx];
      const baseY = horizonY + idx * 38; // vertical stacking
      const col = color(layer.color[0], layer.color[1], layer.color[2], layer.alpha);
      fill(col);

      beginShape();
      vertex(0, height);
      vertex(0, baseY + waveY(0, t, layer));
      const step = 6; // polygon resolution
      for (let x = 0; x <= width; x += step){
        vertex(x, baseY + waveY(x, t, layer));
      }
      vertex(width, height);
      endShape(CLOSE);

      // Rim light/foam hints on crests
      stroke(255, 255, 255, 22 + idx*6);
      noFill();
      for (let x = 0; x < width; x += 8){
        const y = baseY + waveY(x, t, layer);
        point(x, y - 1);
      }
      noStroke();
    }

    function draw(){
      if (!paused) t += deltaTime * 0.002; // animation speed

      const horizonY = drawSky();

      // Draw waves back-to-front
      for (let i = 0; i < LAYERS.length; i++){
        drawLayer(horizonY, i);
      }

      // Gentle shoreline sparkle near foreground
      const sparkY = horizonY + (LAYERS.length-1) * 38 + 6;
      for (let i = 0; i < 240; i++){
        const x = noise(t*0.2 + i*0.13) * width;
        const y = sparkY + noise(t*0.25 + i*0.31) * 18;
        fill(255, 255, 255, 32);
        circle(x, y, noise(i*0.02) * 2.4);
      }
    }
  </script>
</body>
</html>
